import tl = require('azure-pipelines-task-lib/task');
import { ChildProcess } from 'child_process';
import { ProjectCheckResult } from './project-check-result';
const { exec } = require('child-process-async');
import fg = require('fast-glob');

async function run(): Promise<void> {
  try {
    const projectGlobPath: string | undefined = tl.getInput('projectPath', true);
    const includeTransitiveDependencies = tl.getInput('includeTransitiveDependencies', true) !== 'false';
    const thresholdForFailure = tl.getInput('thresholdForFailure', true);
    const projectFiles = await getProjectFilesAsync(projectGlobPath!);
    let failureString = '';

    for await (const pf of projectFiles) {
      var checkResult = await checkProjectAsync(pf, includeTransitiveDependencies, thresholdForFailure!);

      if (!checkResult.wasSuccess) {
        failureString = failureString + checkResult.errorMessage + '\r\n';
      }
    }

    if (failureString !== '') {
      tl.setResult(tl.TaskResult.Failed, failureString);
    } else {
      tl.setResult(tl.TaskResult.Succeeded, 'Everything is awesome');
    }
  }
  catch (err: any) {
    tl.setResult(tl.TaskResult.Failed, 'Task failed with exception: ' + err.message);
  }
}

async function getProjectFilesAsync(projectGlobPath: string): Promise<string[]> {
  projectGlobPath = projectGlobPath.split('\\').join('/');
  projectGlobPath = projectGlobPath.split('//').join('/');

  const result = await fg(projectGlobPath);
  return result;
}

function checkCliReturnTextContainsWarnings(text: string, thresholdForFailure: string): boolean {
  const keywords = [
    {
      value: 'Critical',
      prio: 3
    },
    {
      value: 'High',
      prio: 2
    }, 
    {
      value: 'Moderate',
      prio: 1
    }
  ];

  const threshHoldPrio = keywords.find(kw => kw.value === thresholdForFailure)?.prio;
  let foundWarning = false;

  keywords.forEach(kw => {
    if (text.includes(kw.value)) {
      if (kw.prio >= threshHoldPrio!) {
        foundWarning = true;
      } else {
        console.info(`Found ${kw.value} vulnerability but it is below threshold ${thresholdForFailure}`);
      }
    }
  });

  return foundWarning;
}

async function checkProjectAsync(projectPath: string, includeTransitiveDependencies: boolean, thresholdForFailure: string): Promise<ProjectCheckResult> {
  const command = `dotnet list ${projectPath} package --vulnerable ${includeTransitiveDependencies ? '--include-transitive' : ''}`;
  const netCliResult: ChildProcess = await exec(command, {});
  
  if (netCliResult.stderr) {
    return new ProjectCheckResult(false, 'Task failed with stderr: ' + netCliResult.stderr);
  }

  const text = netCliResult.stdout! as any as string;
  if (checkCliReturnTextContainsWarnings(text, thresholdForFailure)) {
    return new ProjectCheckResult(false, text);
  }

  return new ProjectCheckResult(true);
}

run();