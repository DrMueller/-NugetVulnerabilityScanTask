import tl = require('azure-pipelines-task-lib/task');
import { ChildProcess } from 'child_process';
import { ProjectCheckResult } from './project-check-result';
const { exec } = require('child-process-async');
import fg = require('fast-glob');

async function run(): Promise<void> {
  try {
    const projectGlobPath: string | undefined = tl.getInput('projectPath', true);
    const includeTransitiveDependencies = !!tl.getInput('includeTransitiveDependencies', true);
    const projectFiles = await getProjectFilesAsync(projectGlobPath!);
    console.log(`Found ${projectFiles.length} project files for glob ${projectGlobPath}`)
    let failureString = '';

    for await (const pf of projectFiles) {
      var checkResult = await checkProjectAsync(pf, includeTransitiveDependencies);

      if (!checkResult.wasSuccess) {
        failureString = checkResult.errorMessage + '\r\n';
      }
    }

    if (failureString !== '') {
      tl.setResult(tl.TaskResult.Failed, failureString);
    } else {
      tl.setResult(tl.TaskResult.Succeeded, 'Everything is awesome');
    }
  }
  catch (err: any) {
    tl.setResult(tl.TaskResult.Failed, 'Task failed with exception: ' + err.message);
  }
}

async function getProjectFilesAsync(projectGlobPath: string): Promise<string[]> {
  projectGlobPath = projectGlobPath.split('\\').join('/');
  projectGlobPath = projectGlobPath.split('//').join('/');

  const result = await fg(projectGlobPath);
  return result;
}

function checkCliReturnTextContainsWarnings(text: string): boolean {
  const keywords = ['Critical', 'High', 'Moderate'];
  let foundWarning = false;

  keywords.forEach(kw => {
    if (text.includes(kw)) {
      foundWarning = true;
    }
  });

  return foundWarning;
}

async function checkProjectAsync(projectPath: string, includeTransitiveDependencies: boolean): Promise<ProjectCheckResult> {
  const netCliResult: ChildProcess = await exec(`dotnet list ${projectPath} package --vulnerable ${includeTransitiveDependencies ? '--include-transitive' : ''}`, {});

  if (netCliResult.stderr) {
    return new ProjectCheckResult(false, 'Task failed with stderr: ' + netCliResult.stderr);
  }

  const text = netCliResult.stdout! as any as string;
  // console.log(`CLI result for ${projectPath}: ${text}`);

  if (checkCliReturnTextContainsWarnings(text)) {
    tl.setResult(tl.TaskResult.Failed, text);
    return new ProjectCheckResult(false, text);
  }

  return new ProjectCheckResult(true);
}

run();